# ng2boot
A minimal Angular2 and Spring Boot starter project

The steps to create this project are described in detail in this blog post: https://blog.jdriven.com/2016/12/angular2-spring-boot-getting-started



# ng2boot
A minimal Angular2 and Spring Boot starter project

The steps to create this project are described in detail in this blog post: https://blog.jdriven.com/2016/12/angular2-spring-boot-getting-started



angular 2 quick start



<img src="src/main/frontend/public/boot-logo.png" height="120px"><img style="margin-bottom: 20px" src="src/main/frontend/public/plus.png" height="80px"><img src="src/main/frontend/public/ng-logo.png" height="120px">
# Spring Boot and Angular 2 starter app

> Starter webapp using Spring Boot on the backend and Angular 2 on the frontend, with 
Maven and Angular CLI as build tools and with hot reloading on both sides.

## Quickstart
Run the app:

    git clone https://github.com/dlizarra/spring-angular2-cli-starter.git
    cd spring-angular2-cli-starter
    mvn spring-boot:run

The app will be available at `http://localhost:8080`. 

There's also a sample REST endpoint at [/users](http://localhost:8080/users), the H2 console at [/h2-console](http://localhost:8080/h2-console) and all the endpoints exposed by [Spring Boot Actuator](http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html) ([/health](http://localhost:8080/health), [/beans](http://localhost:8080/beans), etc.)


## Start developing
The Java code is available at `src/main/java` as usual, and the frontend source files are in 
`src/main/frontend`.

### Running the backend
Run `StarterMain` class from your IDE.

### Running the frontend
Go to `src/main/frontend` and run `ng serve`.

Now we should work with `http://localhost:4200` since this is where the Livereload server will serve the content. All the requests will be proxied to the Spring Boot backend at `http://localhost:8080`.

We can change the proxy url in the [.ember-cli](src/main/frontend/.ember-cli) file.

### How the build process works
There are only  configuration files involved:

- [package.json](src/main/frontend/package.json) where we have a "build" script that runs `ng build`.
- [pom.xml](pom.xml#L139) in which we configure the frontend-maven-plugin to run this "build" script during the `generate-sources` phase.
- The [.ember-cli](src/main/frontend/.ember-cli) file where we specify the output directory for the compiled frontend files, which is `src/main/resources/static`.


When we run `mvn spring-boot:run` the frontend source files will be compiled and left at `src/main/resources/static` which is one of the default locations that Spring Boot specifies for static content (the others are /META-INF/resources, /resources and /public), so it will take those files and move them to `target/classes/static`.


### Hot reloading
In the **backend** we make use of Spring DevTools to enable hot reloading, 
so every time we make a change in our files an application restart will
be triggered automatically.

Keep in mind that Spring DevTools automatic restart only works if we run the 
application by running the main method in our app, and not if for example we run 
the app with maven with `mvn spring-boot:run`.

In the **frontend** when we run `ng serve` Angular CLI starts an Ember Livereload server that will watch for any change in our frontend files.

### Profiles

The project comes prepared for being used in three different environments plus 
another one for testing. We use Spring Profiles in combination with Boot feature for 
loading properties files by naming convention (application-*\<profile name\>*.properties).

You can find the profile constants in 
[StarterProfiles](src/main/java/com/dlizarra/starter/StarterProfiles.java) 
and the properties files in `src/main/resources`.

### Database
The database connections are configured in 
[DatabaseConfig](src/main/java/com/dlizarra/starter/DatabaseConfig.java)
where we can find a working H2 embedded database connection for the default profile, and the staging and production configurations examples for working with an external database.

Instead of the default JDBC Tomcat connection pool we added a faster [Hikari CP](https://github.com/brettwooldridge/HikariCP) one.

### Repository layer
The project includes three base data repositories:

- [ReadOnlyRepository](src/main/java/com/dlizarra/starter/support/jpa/ReadOnlyRepository.java): We can use this base repository when we want to make sure the application doesn't insert or update that type of entity, as it just exposes a set of methods to read entities.
- [CustomCrudRepository](src/main/java/com/dlizarra/starter/support/jpa/CustomCrudRepository.java): It's the same as the `CrudRepository` that Spring Data provides, but the `findOne`method in the custom version returns a Java 8 `Optional<T>` object instead of `<T>`. It's just a small difference but it avoids having to override the `findOne` method in every repository to make it return an `Optional` object. This repository is intended to be used when we don't need paging or sorting capabilities for that entity.
- [CustomJpaRepository](src/main/java/com/dlizarra/starter/support/jpa/CustomJpaRepository.java): Again, it's there to provide the same funcionality as the Spring `JpaRepository` but returning `Optional<T>`. We can extend this base repository if we want CRUD operations plus paging and sorting capabilities.

### Security
All the boilerplate for the initial Spring Security configuration is already created. These are they key classes:

- [User](src/main/java/com/dlizarra/starter/user/User.java), [Role](src/main/java/com/dlizarra/starter/role/Role.java) and  [RoleName](src/main/java/com/dlizarra/starter/role/RoleName.java) which are populated by [data.sql](src/main/resources/data.sql) file for the default profile only.
- [CustomUserDetails](src/main/java/com/dlizarra/starter/support/security/CustomUserDetails.java)
- [CustomUserDetailsService](src/main/java/com/dlizarra/starter/support/security/CustomUserDetailsService.java)
- [SecurityConfig](src/main/java/com/dlizarra/starter/SecurityConfig.java) with just very basic security rules.

### DTO-Entity mapping
The project includes Orika and it already has a class, [OrikaBeanMapper](src/main/java/com/dlizarra/starter/support/orika/OrikaBeanMapper.java), ready to be injected anywhere and be used to do any mapping. It will also scan the project on startup searching for custom mappers and components.

You can see how to use it in [UserServiceImpl](src/main/java/com/dlizarra/starter/user/UserServiceImpl.java) or in this sample [project](https://github.com/dlizarra/orika-spring-integration).

This, along with Lombok annotations for auto-generating getters, setters, toString methods and such, allows us to have much cleaner Entities and DTOs classes.

### Unit and integration testing
For **unit testing** we included Spring Test, JUnit, Mockito and AssertJ as well as an [AbstractUnitTest](src/test/java/com/dlizarra/starter/support/AbstractUnitTest.java) class that we can extend to include the boilerplate annotations and configuration for every test. [UserServiceTest](src/test/java/com/dlizarra/starter/user/UserServiceTest.java) can serve as an example.

To create integration tests we can extend [AbstractIntegrationTest](src/test/java/com/dlizarra/starter/support/AbstractIntegrationTest.java) and make use of Spring `@sql` annotation to run a databse script before every test, just like it's done in [UserRepositoryTest](src/test/java/com/dlizarra/starter/user/UserRepositoryTest.java).

### Code coverage
The project is also ready to use Cobertura as a code coverage utility and Coveralls to show a nice graphical representation of the results, get a badge with the results, etc. 

The only thing you need to do is to create an account in [Coveralls.io](http://coveralls.io) and add your repo token key [here](pom.xml#L134) in the pom.xml.

And if you want to use different tools you just need to remove the plugins from the pom.


### Continuous integration and deployment
A [travis.yml](.travis.yml) file is included with a minimal configuration just to use jdk 8, trigger the code analysis tool and deploy the app to Heroku using the `api_key` in the file. 

We also included a Heroku [Procfile](Procfile) which declares the `web` process type and the java command to run our app and specifies which Spring Profile we want to use.



## Tech stack and libraries
### Backend
- [Spring Boot](http://projects.spring.io/spring-boot/)
- [Spring MVC](http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/mvc.html)
- [Spring Data](http://projects.spring.io/spring-data/)
- [Spring Security](http://projects.spring.io/spring-security/)
- [Spring Test](http://docs.spring.io/autorepo/docs/spring-framework/3.2.x/spring-framework-reference/html/testing.html)
- [JUnit](http://junit.org/)
- [Mockito](http://mockito.org/)
- [AssertJ](http://joel-costigliola.github.io/assertj/)
- [Lombok](https://projectlombok.org/)
- [Orika](http://orika-mapper.github.io/orika-docs/)
- [Maven](https://maven.apache.org/)

### Frontend
- [Angular 2](https://angular.io/)
- [Angular CLI](https://cli.angular.io/)
- [Moment.js](http://momentjs.com/)


---













<img src="src/main/frontend/public/boot-logo.png" height="120px"><img style="margin-bottom: 20px" src="src/main/frontend/public/plus.png" height="80px"><img src="src/main/frontend/public/ng-logo.png" height="120px">
# Spring Boot and Angular 2 starter app

> Starter webapp using Spring Boot on the backend and Angular 2 on the frontend, with 
Maven and Angular CLI as build tools and with hot reloading on both sides.

## Quickstart
Run the app:

    git clone https://github.com/dlizarra/spring-angular2-cli-starter.git
    cd spring-angular2-cli-starter
    mvn spring-boot:run

The app will be available at `http://localhost:8080`. 

There's also a sample REST endpoint at [/users](http://localhost:8080/users), the H2 console at [/h2-console](http://localhost:8080/h2-console) and all the endpoints exposed by [Spring Boot Actuator](http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-endpoints.html) ([/health](http://localhost:8080/health), [/beans](http://localhost:8080/beans), etc.)


## Start developing
The Java code is available at `src/main/java` as usual, and the frontend source files are in 
`src/main/frontend`.

### Running the backend
Run `StarterMain` class from your IDE.

### Running the frontend
Go to `src/main/frontend` and run `ng serve`.

Now we should work with `http://localhost:4200` since this is where the Livereload server will serve the content. All the requests will be proxied to the Spring Boot backend at `http://localhost:8080`.

We can change the proxy url in the [.ember-cli](src/main/frontend/.ember-cli) file.

### How the build process works
There are only  configuration files involved:

- [package.json](src/main/frontend/package.json) where we have a "build" script that runs `ng build`.
- [pom.xml](pom.xml#L139) in which we configure the frontend-maven-plugin to run this "build" script during the `generate-sources` phase.
- The [.ember-cli](src/main/frontend/.ember-cli) file where we specify the output directory for the compiled frontend files, which is `src/main/resources/static`.


When we run `mvn spring-boot:run` the frontend source files will be compiled and left at `src/main/resources/static` which is one of the default locations that Spring Boot specifies for static content (the others are /META-INF/resources, /resources and /public), so it will take those files and move them to `target/classes/static`.


### Hot reloading
In the **backend** we make use of Spring DevTools to enable hot reloading, 
so every time we make a change in our files an application restart will
be triggered automatically.

Keep in mind that Spring DevTools automatic restart only works if we run the 
application by running the main method in our app, and not if for example we run 
the app with maven with `mvn spring-boot:run`.

In the **frontend** when we run `ng serve` Angular CLI starts an Ember Livereload server that will watch for any change in our frontend files.

### Profiles

The project comes prepared for being used in three different environments plus 
another one for testing. We use Spring Profiles in combination with Boot feature for 
loading properties files by naming convention (application-*\<profile name\>*.properties).

You can find the profile constants in 
[StarterProfiles](src/main/java/com/dlizarra/starter/StarterProfiles.java) 
and the properties files in `src/main/resources`.

### Database
The database connections are configured in 
[DatabaseConfig](src/main/java/com/dlizarra/starter/DatabaseConfig.java)
where we can find a working H2 embedded database connection for the default profile, and the staging and production configurations examples for working with an external database.

Instead of the default JDBC Tomcat connection pool we added a faster [Hikari CP](https://github.com/brettwooldridge/HikariCP) one.

### Repository layer
The project includes three base data repositories:

- [ReadOnlyRepository](src/main/java/com/dlizarra/starter/support/jpa/ReadOnlyRepository.java): We can use this base repository when we want to make sure the application doesn't insert or update that type of entity, as it just exposes a set of methods to read entities.
- [CustomCrudRepository](src/main/java/com/dlizarra/starter/support/jpa/CustomCrudRepository.java): It's the same as the `CrudRepository` that Spring Data provides, but the `findOne`method in the custom version returns a Java 8 `Optional<T>` object instead of `<T>`. It's just a small difference but it avoids having to override the `findOne` method in every repository to make it return an `Optional` object. This repository is intended to be used when we don't need paging or sorting capabilities for that entity.
- [CustomJpaRepository](src/main/java/com/dlizarra/starter/support/jpa/CustomJpaRepository.java): Again, it's there to provide the same funcionality as the Spring `JpaRepository` but returning `Optional<T>`. We can extend this base repository if we want CRUD operations plus paging and sorting capabilities.

### Security
All the boilerplate for the initial Spring Security configuration is already created. These are they key classes:

- [User](src/main/java/com/dlizarra/starter/user/User.java), [Role](src/main/java/com/dlizarra/starter/role/Role.java) and  [RoleName](src/main/java/com/dlizarra/starter/role/RoleName.java) which are populated by [data.sql](src/main/resources/data.sql) file for the default profile only.
- [CustomUserDetails](src/main/java/com/dlizarra/starter/support/security/CustomUserDetails.java)
- [CustomUserDetailsService](src/main/java/com/dlizarra/starter/support/security/CustomUserDetailsService.java)
- [SecurityConfig](src/main/java/com/dlizarra/starter/SecurityConfig.java) with just very basic security rules.

### DTO-Entity mapping
The project includes Orika and it already has a class, [OrikaBeanMapper](src/main/java/com/dlizarra/starter/support/orika/OrikaBeanMapper.java), ready to be injected anywhere and be used to do any mapping. It will also scan the project on startup searching for custom mappers and components.

You can see how to use it in [UserServiceImpl](src/main/java/com/dlizarra/starter/user/UserServiceImpl.java) or in this sample [project](https://github.com/dlizarra/orika-spring-integration).

This, along with Lombok annotations for auto-generating getters, setters, toString methods and such, allows us to have much cleaner Entities and DTOs classes.

### Unit and integration testing
For **unit testing** we included Spring Test, JUnit, Mockito and AssertJ as well as an [AbstractUnitTest](src/test/java/com/dlizarra/starter/support/AbstractUnitTest.java) class that we can extend to include the boilerplate annotations and configuration for every test. [UserServiceTest](src/test/java/com/dlizarra/starter/user/UserServiceTest.java) can serve as an example.

To create integration tests we can extend [AbstractIntegrationTest](src/test/java/com/dlizarra/starter/support/AbstractIntegrationTest.java) and make use of Spring `@sql` annotation to run a databse script before every test, just like it's done in [UserRepositoryTest](src/test/java/com/dlizarra/starter/user/UserRepositoryTest.java).

### Code coverage
The project is also ready to use Cobertura as a code coverage utility and Coveralls to show a nice graphical representation of the results, get a badge with the results, etc. 

The only thing you need to do is to create an account in [Coveralls.io](http://coveralls.io) and add your repo token key [here](pom.xml#L134) in the pom.xml.

And if you want to use different tools you just need to remove the plugins from the pom.


### Continuous integration and deployment
A [travis.yml](.travis.yml) file is included with a minimal configuration just to use jdk 8, trigger the code analysis tool and deploy the app to Heroku using the `api_key` in the file. 

We also included a Heroku [Procfile](Procfile) which declares the `web` process type and the java command to run our app and specifies which Spring Profile we want to use.



## Tech stack and libraries
### Backend
- [Spring Boot](http://projects.spring.io/spring-boot/)
- [Spring MVC](http://docs.spring.io/autorepo/docs/spring/3.2.x/spring-framework-reference/html/mvc.html)
- [Spring Data](http://projects.spring.io/spring-data/)
- [Spring Security](http://projects.spring.io/spring-security/)
- [Spring Test](http://docs.spring.io/autorepo/docs/spring-framework/3.2.x/spring-framework-reference/html/testing.html)
- [JUnit](http://junit.org/)
- [Mockito](http://mockito.org/)
- [AssertJ](http://joel-costigliola.github.io/assertj/)
- [Lombok](https://projectlombok.org/)
- [Orika](http://orika-mapper.github.io/orika-docs/)
- [Maven](https://maven.apache.org/)

### Frontend
- [Angular 2](https://angular.io/)
- [Angular CLI](https://cli.angular.io/)
- [Moment.js](http://momentjs.com/)


---












# Angular QuickStart Source
[![Build Status][travis-badge]][travis-badge-url]

This repository holds the TypeScript source code of the [angular.io quickstart](https://angular.io/docs/ts/latest/quickstart.html),
the foundation for most of the documentation samples and potentially a good starting point for your application.

It's been extended with testing support so you can start writing tests immediately.

**This is not the perfect arrangement for your application. It is not designed for production.
It exists primarily to get you started quickly with learning and prototyping in Angular**

We are unlikely to accept suggestions about how to grow this QuickStart into something it is not.
Please keep that in mind before posting issues and PRs.

## Updating to a newer version of the Quickstart Repo

From time to time the QuickStart will be enhanced with support for new features or to reflect
changes to the [official Style Guide](https://angular.io/docs/ts/latest/guide/style-guide.html).

You can update your existing project to an up-to-date QuickStart by following these instructions:
- Create a new project using the [instructions below](#create-a-new-project-based-on-the-quickstart)
- Copy the code you have in your project's `main.ts` file onto `src/app/main.ts` in the new project
- Copy your old `app` folder into `src/app`
- Delete `src/app/main.ts` if you have one (we now use `src/main.ts` instead)
- Copy your old `index.html`, `styles.css` and `tsconfig.json` into `src/`
- Install all your third party dependencies
- Copy your old `e2e/` folder into `e2e/`
- Copy over any other files you added to your project
- Copy your old `.git` folder into your new project's root

Now you can continue working on the new project.

## Prerequisites

Node.js and npm are essential to Angular development. 
    
<a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" title="Installing Node.js and updating npm">
Get it now</a> if it's not already installed on your machine.
 
**Verify that you are running at least node `v4.x.x` and npm `3.x.x`**
by running `node -v` and `npm -v` in a terminal/console window.
Older versions produce errors.

We recommend [nvm](https://github.com/creationix/nvm) for managing multiple versions of node and npm.

## Create a new project based on the QuickStart

Clone this repo into new project folder (e.g., `my-proj`).
```shell
git clone https://github.com/angular/quickstart  my-proj
cd my-proj
```

We have no intention of updating the source on `angular/quickstart`.
Discard the `.git` folder..
```shell
rm -rf .git  # OS/X (bash)
rd .git /S/Q # windows
```
### Delete _non-essential_ files (optional)

You can quickly delete the _non-essential_ files that concern testing and QuickStart repository maintenance
(***including all git-related artifacts*** such as the `.git` folder and `.gitignore`!)
by entering the following commands while in the project folder:

##### OS/X (bash)
```shell
xargs rm -rf < non-essential-files.osx.txt
rm src/app/*.spec*.ts
rm non-essential-files.osx.txt
```

##### Windows
```shell
for /f %i in (non-essential-files.txt) do del %i /F /S /Q
rd .git /s /q
rd e2e /s /q
```

### Create a new git repo
You could [start writing code](#start-development) now and throw it all away when you're done.
If you'd rather preserve your work under source control, consider taking the following steps.

Initialize this project as a *local git repo* and make the first commit:
```shell
git init
git add .
git commit -m "Initial commit"
```

>Recover the deleted `.gitignore` from the QuickStart repository 
if you lost it in the _Delete non-essential files_ step.

Create a *remote repository* for this project on the service of your choice.

Grab its address (e.g. *`https://github.com/<my-org>/my-proj.git`*) and push the *local repo* to the *remote*.
```shell
git remote add origin <repo-address>
git push -u origin master
```
## Install npm packages

> See npm and nvm version notes above

Install the npm packages described in the `package.json` and verify that it works:

```shell
npm install
npm start
```

>Doesn't work in _Bash for Windows_ which does not support servers as of January, 2017.

The `npm start` command first compiles the application, 
then simultaneously re-compiles and runs the `lite-server`.
Both the compiler and the server watch for file changes.

Shut it down manually with `Ctrl-C`.

You're ready to write your application.

### npm scripts

We've captured many of the most useful commands in npm scripts defined in the `package.json`:

* `npm start` - runs the compiler and a server at the same time, both in "watch mode".
* `npm run build` - runs the TypeScript compiler once.
* `npm run build:w` - runs the TypeScript compiler in watch mode; the process keeps running, awaiting changes to TypeScript files and re-compiling when it sees them.
* `npm run serve` - runs the [lite-server](https://www.npmjs.com/package/lite-server), a light-weight, static file server, written and maintained by
[John Papa](https://github.com/johnpapa) and
[Christopher Martin](https://github.com/cgmartin)
with excellent support for Angular apps that use routing.

Here are the test related scripts:
* `npm test` - compiles, runs and watches the karma unit tests
* `npm run e2e` - compiles and run protractor e2e tests, written in Typescript (*e2e-spec.ts)

## Testing

The QuickStart documentation doesn't discuss testing.
This repo adds both karma/jasmine unit test and protractor end-to-end testing support.

These tools are configured for specific conventions described below.

*It is unwise and rarely possible to run the application, the unit tests, and the e2e tests at the same time.
We recommend that you shut down one before starting another.*

### Unit Tests
TypeScript unit-tests are usually in the `src/app` folder. Their filenames must end in `.spec.ts`.

Look for the example `src/app/app.component.spec.ts`.
Add more `.spec.ts` files as you wish; we configured karma to find them.

Run it with `npm test`

That command first compiles the application, then simultaneously re-compiles and runs the karma test-runner.
Both the compiler and the karma watch for (different) file changes.

Shut it down manually with `Ctrl-C`.

Test-runner output appears in the terminal window.
We can update our app and our tests in real-time, keeping a weather eye on the console for broken tests.
Karma is occasionally confused and it is often necessary to shut down its browser or even shut the command down (`Ctrl-C`) and
restart it. No worries; it's pretty quick.

### End-to-end (E2E) Tests

E2E tests are in the `e2e` directory, side by side with the `src` folder.
Their filenames must end in `.e2e-spec.ts`.

Look for the example `e2e/app.e2e-spec.ts`.
Add more `.e2e-spec.js` files as you wish (although one usually suffices for small projects);
we configured Protractor to find them.

Thereafter, run them with `npm run e2e`.

That command first compiles, then simultaneously starts the `lite-server` at `localhost:8080`
and launches Protractor.  

The pass/fail test results appear at the bottom of the terminal window.
A custom reporter (see `protractor.config.js`) generates a  `./_test-output/protractor-results.txt` file
which is easier to read; this file is excluded from source control.

Shut it down manually with `Ctrl-C`.

[travis-badge]: https://travis-ci.org/angular/quickstart.svg?branch=master
[travis-badge-url]: https://travis-ci.org/angular/quickstart













# Angular QuickStart Source
[![Build Status][travis-badge]][travis-badge-url]

This repository holds the TypeScript source code of the [angular.io quickstart](https://angular.io/docs/ts/latest/quickstart.html),
the foundation for most of the documentation samples and potentially a good starting point for your application.

It's been extended with testing support so you can start writing tests immediately.

**This is not the perfect arrangement for your application. It is not designed for production.
It exists primarily to get you started quickly with learning and prototyping in Angular**

We are unlikely to accept suggestions about how to grow this QuickStart into something it is not.
Please keep that in mind before posting issues and PRs.

## Updating to a newer version of the Quickstart Repo

From time to time the QuickStart will be enhanced with support for new features or to reflect
changes to the [official Style Guide](https://angular.io/docs/ts/latest/guide/style-guide.html).

You can update your existing project to an up-to-date QuickStart by following these instructions:
- Create a new project using the [instructions below](#create-a-new-project-based-on-the-quickstart)
- Copy the code you have in your project's `main.ts` file onto `src/app/main.ts` in the new project
- Copy your old `app` folder into `src/app`
- Delete `src/app/main.ts` if you have one (we now use `src/main.ts` instead)
- Copy your old `index.html`, `styles.css` and `tsconfig.json` into `src/`
- Install all your third party dependencies
- Copy your old `e2e/` folder into `e2e/`
- Copy over any other files you added to your project
- Copy your old `.git` folder into your new project's root

Now you can continue working on the new project.

## Prerequisites

Node.js and npm are essential to Angular development. 
    
<a href="https://docs.npmjs.com/getting-started/installing-node" target="_blank" title="Installing Node.js and updating npm">
Get it now</a> if it's not already installed on your machine.
 
**Verify that you are running at least node `v4.x.x` and npm `3.x.x`**
by running `node -v` and `npm -v` in a terminal/console window.
Older versions produce errors.

We recommend [nvm](https://github.com/creationix/nvm) for managing multiple versions of node and npm.

## Create a new project based on the QuickStart

Clone this repo into new project folder (e.g., `my-proj`).
```shell
git clone https://github.com/angular/quickstart  my-proj
cd my-proj
```

We have no intention of updating the source on `angular/quickstart`.
Discard the `.git` folder..
```shell
rm -rf .git  # OS/X (bash)
rd .git /S/Q # windows
```
### Delete _non-essential_ files (optional)

You can quickly delete the _non-essential_ files that concern testing and QuickStart repository maintenance
(***including all git-related artifacts*** such as the `.git` folder and `.gitignore`!)
by entering the following commands while in the project folder:

##### OS/X (bash)
```shell
xargs rm -rf < non-essential-files.osx.txt
rm src/app/*.spec*.ts
rm non-essential-files.osx.txt
```

##### Windows
```shell
for /f %i in (non-essential-files.txt) do del %i /F /S /Q
rd .git /s /q
rd e2e /s /q
```

### Create a new git repo
You could [start writing code](#start-development) now and throw it all away when you're done.
If you'd rather preserve your work under source control, consider taking the following steps.

Initialize this project as a *local git repo* and make the first commit:
```shell
git init
git add .
git commit -m "Initial commit"
```

>Recover the deleted `.gitignore` from the QuickStart repository 
if you lost it in the _Delete non-essential files_ step.

Create a *remote repository* for this project on the service of your choice.

Grab its address (e.g. *`https://github.com/<my-org>/my-proj.git`*) and push the *local repo* to the *remote*.
```shell
git remote add origin <repo-address>
git push -u origin master
```
## Install npm packages

> See npm and nvm version notes above

Install the npm packages described in the `package.json` and verify that it works:

```shell
npm install
npm start
```

>Doesn't work in _Bash for Windows_ which does not support servers as of January, 2017.

The `npm start` command first compiles the application, 
then simultaneously re-compiles and runs the `lite-server`.
Both the compiler and the server watch for file changes.

Shut it down manually with `Ctrl-C`.

You're ready to write your application.

### npm scripts

We've captured many of the most useful commands in npm scripts defined in the `package.json`:

* `npm start` - runs the compiler and a server at the same time, both in "watch mode".
* `npm run build` - runs the TypeScript compiler once.
* `npm run build:w` - runs the TypeScript compiler in watch mode; the process keeps running, awaiting changes to TypeScript files and re-compiling when it sees them.
* `npm run serve` - runs the [lite-server](https://www.npmjs.com/package/lite-server), a light-weight, static file server, written and maintained by
[John Papa](https://github.com/johnpapa) and
[Christopher Martin](https://github.com/cgmartin)
with excellent support for Angular apps that use routing.

Here are the test related scripts:
* `npm test` - compiles, runs and watches the karma unit tests
* `npm run e2e` - compiles and run protractor e2e tests, written in Typescript (*e2e-spec.ts)

## Testing

The QuickStart documentation doesn't discuss testing.
This repo adds both karma/jasmine unit test and protractor end-to-end testing support.

These tools are configured for specific conventions described below.

*It is unwise and rarely possible to run the application, the unit tests, and the e2e tests at the same time.
We recommend that you shut down one before starting another.*

### Unit Tests
TypeScript unit-tests are usually in the `src/app` folder. Their filenames must end in `.spec.ts`.

Look for the example `src/app/app.component.spec.ts`.
Add more `.spec.ts` files as you wish; we configured karma to find them.

Run it with `npm test`

That command first compiles the application, then simultaneously re-compiles and runs the karma test-runner.
Both the compiler and the karma watch for (different) file changes.

Shut it down manually with `Ctrl-C`.

Test-runner output appears in the terminal window.
We can update our app and our tests in real-time, keeping a weather eye on the console for broken tests.
Karma is occasionally confused and it is often necessary to shut down its browser or even shut the command down (`Ctrl-C`) and
restart it. No worries; it's pretty quick.

### End-to-end (E2E) Tests

E2E tests are in the `e2e` directory, side by side with the `src` folder.
Their filenames must end in `.e2e-spec.ts`.

Look for the example `e2e/app.e2e-spec.ts`.
Add more `.e2e-spec.js` files as you wish (although one usually suffices for small projects);
we configured Protractor to find them.

Thereafter, run them with `npm run e2e`.

That command first compiles, then simultaneously starts the `lite-server` at `localhost:8080`
and launches Protractor.  

The pass/fail test results appear at the bottom of the terminal window.
A custom reporter (see `protractor.config.js`) generates a  `./_test-output/protractor-results.txt` file
which is easier to read; this file is excluded from source control.

Shut it down manually with `Ctrl-C`.

[travis-badge]: https://travis-ci.org/angular/quickstart.svg?branch=master
[travis-badge-url]: https://travis-ci.org/angular/quickstart


# Introduction

[AngularJS 2](https://angular.io/) implementation of the [RDash admin dashboard](http://rdash.github.io) theme

> Responsive, bloat free, bootstrap powered admin style dashboard!

**Note:** ~~Angular 2.0 is not production ready yet! This project is perfect for playing around with the latest versions but do not start new projects with it since a lot of new changes are going to be introduced until the framework is officially released.~~

[**Demo App**](https://rdash-angular2.herokuapp.com/)

# How to start

```bash
git clone https://github.com/ziyasal/rdash-angular2.git
cd rdash-angular2
npm install
# dev
npm start
```

## Components

- RdWidget
- RdWidgetHeader
- RdWidgetBody
- RdWidgetFooter
- RdLoading


**Simple Widget** 
```js
    <rd-widget>
      <rd-widget-body>       
       <span>HTML CONTENT</span>       
      </rd-widget-body>
    </rd-widget>
```

**Widget with Header**  
```js
 <rd-widget>
       <rd-widget-header icon="fa-tasks" title="Servers">
         <a href="javascript:void(0)" style="float: right">Manage</a>
       </rd-widget-header>
       <rd-widget-body classes="medium no-padding">
         <server-list-view [model]="servers"></server-list-view>
       </rd-widget-body>
     </rd-widget>
```

**Widget with Footer**  
```js
 <rd-widget>
       <rd-widget-header icon="fa-tasks" title="Servers">
         <a href="javascript:void(0)" style="float: right">Manage</a>
       </rd-widget-header>
       <rd-widget-body classes="medium no-padding">
         <server-list-view [model]="servers"></server-list-view>
       </rd-widget-body>
       <rd-widget-footer>
         <span>FOOTER CONTENT</span>
       </rd-widget-footer>
     </rd-widget>
```

**Widget with Loader**  
```js
 <rd-widget>
    <rd-widget-body classes="medium no-padding">
       <rd-loading></rd-loading>
    </rd-widget-body>
 </rd-widget>
```

# License

[MIT](https://raw.githubusercontent.com/ziyasal/rdash-angular2/master/LICENSE)




Predix Development Kit - NodeJs Starter Application
==========================================================

This is simple starter Node application that demonstrates user authentication with Predix UAA,
and integration with microservices.

## Running locally
Edit the config.json to run the application locally for your UAA client.

Sample :
```
"development":{
  "clientId": "${clientId}",
  "uaaUri" : "${UAA URL}",
  "base64ClientCredential": "${base 64 encoding of clientId:secret}",
  "appUrl": "http://localhost:3000",
  "assetZoneId": "${asset zone id for Asset service instantiated}",
  "tagname": "${tag name list to query. Separated by comma}",
  "assetURL": "${The asset url to query the tags from. https://<assetURI>/<assetType>}",
  "timeseries_zone": "${timeseries zone id for Timeseries service instantiated}",
  "timeseriesURL": "${Timeseries to query for data. <TimeseriesURI>/v1/datapoints}",
  "uaaURL": "${The UAA URI. <UaaURI>/predix.io",
}
```
*Note:* You can encode your clientId:secret combination using <https://www.base64encode.org/> or the base64 command on Unix / Mac OSX.

`echo -n clientId:clientSecret | base64`

#### Install and start local web server
```
npm install
node app.js or npm start
```
Navigate to <http://localhost:3000> in your web browser.

Debugging  
```
DEBUG=predix-boot-node-app:* npm start
DEBUG=express:* npm start
```

#### Run sample tests
A sample unit test is included, which you can run with npm:
`npm test`

#### Running locally behind a corporate firewall

If you are behind a corporate firewall, make sure you have the `http_proxy` environment variable set in the same terminal window where you start the server.

## Running in the cloud

Set up the manifest file for Cloud deployment

1. Copy manifest.yml.template to my-app-manifest.yml.
2. Edit the my-app-manifest.yml
```
---
applications:
- name: <front end app name>
  memory: 128M
  buildpack: nodejs_buildpack
  #command:  DEBUG=express:* node app.js
  command:  node app.js
services:
- <asset instance service name>
- <timeseries instance service name>
- <uaa instance service name>
env:
    node_env: cloud
    uaa_service_label : predix-uaa
    clientId: <client id with timeseries and asset scope>
    base64ClientCredential: <base64 encoding of client id>
    # Following properties configured only for Timeseries WindData service Integration
    assetMachine: <The asset name pushed to Asset service>
    tagname: <The asset tag pushed to Asset service>
```

`predix push <appName> -f my-app-manifest.yml`

[![Analytics](https://ga-beacon.appspot.com/UA-82773213-1/predix-nodejs-starter/readme?pixel)](https://github.com/PredixDev)
 
